Asynchronous programming for Python
-----------------------------------
C# like Async/Await paradigm for asynchronous programming in Python

#------------------------------------------------------------------------------#
# Types                                                                        #
#------------------------------------------------------------------------------#
Future:
-------
    Main type to keep/pass/wait result of asynchronous operation

    Methods:
        #------------------------------------------------------------------#
        # State                                                            #
        #------------------------------------------------------------------#
        Result () -> T
            Get result of future
            if future is completed successfully returns result of the future
            if future is failed reraise an error
            if future is not completed raise FutureNotReady

        Error () -> (ExceptionType, Exception, Traceback)?
            Error or None if future is completed successfully or not completed

        IsCompleted () -> bool
            Check if future is completed

        #------------------------------------------------------------------#
        # Continuation                                                     #
        #------------------------------------------------------------------#
        Continue (cont:Func<Future<T>, TResult>) -> Future<TResult>
            Continue with function "cont" with future as argument

        ContinueWithFunction (func:Func<T, TResult>) -> Future<TResult>
            Continue with function "func" with result as argument

        ContinueWithAsync (async:Func<T, Future<TResult>>) -> Future<TResult>
            Continue with asynchronous function "async" and pass result as argume

        Unwrap () -> Future<TResult>
            Unwrap nested future. For example Future<Future<T>> -> Future<T>

    Properties:
        Wait:
            Wait object (callable)

        Cancel:
            Cancel object (callable)

Core:
-----
    Asynchronous core for IO/Sleep operations

    Methods:
        #------------------------------------------------------------------#
        # Running                                                          #
        #------------------------------------------------------------------#
        Instance () -> None
            Singleton instance

        Run () -> None
            Run core

        Stop () -> None
            Stop core

        #------------------------------------------------------------------#
        # Polling                                                          #
        #------------------------------------------------------------------#
        Poll (fd:int, mask:int) -> Future<int>
            Wait for "mask" event on descriptor "fd" on success return event mask
            It also can raise:
                CoreDisconnectedError - the device has been disconnected
                CoreInvalidError      - the specified fd is invalid
                CoreIOError           - an error has occurred on the device or stream

        #------------------------------------------------------------------#
        # Sleeping                                                         #
        #------------------------------------------------------------------#
        Sleep (delay:float) -> Future<float>
            Complete future after at least "delay" seconds have passed

        SleepUntil (time:float) -> Future<float>
            Complete future after "time" (unix time) has been reached

        Idle () -> Future<None>
            Complete sometime later

Asynchronous Objects:
---------------------

    AsyncFile:
        #----------------------------------------------------------#
        # Reading                                                  #
        #----------------------------------------------------------#
        Read (size:int) -> Future<data>
        ReadExactly (size:int) -> Future<data>
        ReadExactlyInto (size:int, stream:stream) -> Future<stream>

        #----------------------------------------------------------#
        # Writing                                                  #
        #----------------------------------------------------------#
        Write (data) -> Future<None>
        WriteNoWait (data) -> None


    AsyncSocket is an AsyncFile with additional methods
        #----------------------------------------------------------#
        # Socket Methods                                           #
        #----------------------------------------------------------#
        Connect (address:?) -> Future<AsyncSocket>
        Bind (address) -> None
        Listen (backlog) -> None
        Accept () -> Future<(AsyncSocket, address)>

#------------------------------------------------------------------------------#
# Functions                                                                    #
#------------------------------------------------------------------------------#
Composition:
------------
    AnyFuture (IEnumerable <futures:Future<Object>>) -> Future<Future<Object>>
        Future with the first resolved future as result

    AllFuture (IEnumerable <futures:Future<Object>>) -> Future<None>
        Future wich will be resolved when all futures are resolved

#------------------------------------------------------------------------------#
# Decorators                                                                   #
#------------------------------------------------------------------------------#
Async:
    Decorator converting generator to asynchronous function

DummyAsync:
    Wrap result of funciton into Future

Sink:
    Limit access to asynchronous function

#------------------------------------------------------------------------------#
# Example: Echo Server                                                         #
#------------------------------------------------------------------------------#
import socket
from async import *

def main ():
    with Core.Instance ():
        # create server socket
        sock = AsyncSocket (socket.socket ())
        sock.Bind (('localhost', 8000))
        sock.Listen (10)

        @Async
        def process (client):
            while True:
                # wait for new data
                data = yield client.Read (1 << 20)
                if len (data) == 0:
                    # connection has been closed
                    return
                # wait for data to be send
                yield client.Write (data)

        @Async
        def server ():
            while True:
                # wait for new connection
                client, addr = yield sock.Accept ()
                # create coroutine for handling this client
                process (client).Traceback ('process')

        # start accepting coroutine
        server ().Traceback ('server')

if __name__ == '__main__':
    main ()

# vim: nu columns=120 :
